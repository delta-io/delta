/*
 * Copyright (2021) The Delta Lake Project Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.delta.flink.sink;

import io.delta.kernel.data.Row;
import io.delta.kernel.defaults.internal.json.JsonUtils;
import io.delta.kernel.internal.actions.SingleAction;
import io.delta.kernel.internal.util.Preconditions;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.flink.core.io.SimpleVersionedSerializer;

/**
 * {@code DeltaWriterResult} represents the output produced by a {@code DeltaSinkWriter} for a
 * single checkpoint.
 *
 * <p>A {@code DeltaWriterResult} contains the Delta actions generated by one writer subtask while
 * processing records up to a checkpoint barrier. These actions typically correspond to data written
 * to storage (for example, {@code AddFile} actions) and are grouped according to the table’s
 * partitioning scheme.
 *
 * <p>This object is emitted by the writer and forwarded to downstream aggregation and commit
 * components (such as an aggregator or committer) as part of Flink’s exactly-once checkpointing
 * protocol.
 *
 * <p>{@code DeltaWriterResult} itself does not perform any commit operations. Instead, it serves as
 * an immutable, checkpoint-scoped container that:
 *
 * <ul>
 *   <li>captures all actions generated by a single writer subtask,
 *   <li>represents data written since the previous successful checkpoint, and
 *   <li>can be safely replayed or discarded during failure recovery.
 * </ul>
 *
 * <p>Instances of this class are expected to be serializable and deterministic to ensure correct
 * recovery behavior when checkpoints are retried.
 *
 * <p>Typical lifecycle:
 *
 * <ol>
 *   <li>{@code DeltaSinkWriter} writes data files and constructs Delta actions.
 *   <li>A {@code DeltaWriterResult} is emitted at checkpoint time.
 *   <li>Multiple writer results are aggregated into committables.
 *   <li>The committer applies the aggregated actions to the Delta table.
 * </ol>
 */
public class DeltaWriterResult implements Serializable {
  /** Auxiliary information need to be carried together with the result */
  private final WriterResultContext context;

  private final List<Row> deltaActions;

  public DeltaWriterResult() {
    this(new ArrayList<>(), new WriterResultContext());
  }

  public DeltaWriterResult(List<Row> deltaActions, WriterResultContext context) {
    this.deltaActions = deltaActions;
    this.context = context;
  }

  public WriterResultContext getContext() {
    return context;
  }

  public List<Row> getDeltaActions() {
    return deltaActions;
  }

  /**
   * Merge another DeltaWriterResult into the current one
   *
   * @param another the result to be merged
   * @return this instance after merge
   */
  public DeltaWriterResult merge(DeltaWriterResult another) {
    this.deltaActions.addAll(another.deltaActions);
    this.context.merge(another.context);
    return this;
  }

  @Override
  public String toString() {
    return "DeltaWriterResult{"
        + "context='"
        + context.toString()
        + '\''
        + ", deltaActions="
        + deltaActions.stream().map(JsonUtils::rowToJson).collect(Collectors.joining(","))
        + '}';
  }

  static class Serializer implements SimpleVersionedSerializer<DeltaWriterResult> {
    @Override
    public int getVersion() {
      return 1;
    }

    @Override
    public byte[] serialize(DeltaWriterResult obj) throws IOException {
      try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
          ObjectOutputStream out = new ObjectOutputStream(bos)) {
        out.writeObject(obj.getContext());
        out.writeInt(obj.getDeltaActions().size());
        for (Row row : obj.getDeltaActions()) {
          Preconditions.checkArgument(
              row.getSchema().equivalent(SingleAction.FULL_SCHEMA), "Need to be an action");
          out.writeUTF(JsonUtils.rowToJson(row));
        }
        out.flush();
        return bos.toByteArray();
      }
    }

    @Override
    public DeltaWriterResult deserialize(int version, byte[] serialized) throws IOException {
      try (ByteArrayInputStream bis = new ByteArrayInputStream(serialized);
          ObjectInputStream in = new ObjectInputStream(bis)) {
        WriterResultContext context = (WriterResultContext) in.readObject();
        final int numActions = in.readInt();
        List<Row> actions = new ArrayList<>(numActions);
        for (int i = 0; i < numActions; i++) {
          final String actionJson = in.readUTF();
          actions.add(JsonUtils.rowFromJson(actionJson, SingleAction.FULL_SCHEMA));
        }
        return new DeltaWriterResult(actions, context);
      } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
      }
    }
  }
}
