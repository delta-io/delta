/*
 * Copyright (2021) The Delta Lake Project Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.delta.flink.table;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import dev.failsafe.function.CheckedSupplier;
import io.delta.kernel.internal.types.DataTypeJsonSerDe;
import io.delta.kernel.types.*;
import io.unitycatalog.client.ApiClient;
import io.unitycatalog.client.ApiClientBuilder;
import io.unitycatalog.client.ApiException;
import io.unitycatalog.client.api.SchemasApi;
import io.unitycatalog.client.api.TablesApi;
import io.unitycatalog.client.api.TemporaryCredentialsApi;
import io.unitycatalog.client.auth.TokenProvider;
import io.unitycatalog.client.model.*;
import io.unitycatalog.client.retry.JitterDelayRetryPolicy;
import java.net.URI;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.flink.util.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A {@code UnityCatalog} is a {@link DeltaCatalog} implementation that interacts with an external
 * catalog service via UnityCatalog OSS APIs.
 *
 * <p>This catalog resolves table metadata and access credentials by communicating with a remote
 * catalog endpoint. It is typically used in environments where table discovery, authorization, and
 * credential issuance are managed centrally by a service rather than through filesystem-based
 * catalogs.
 *
 * <p>The catalog uses:
 *
 * <ul>
 *   <li>a REST endpoint to load table metadata (e.g., storage location, table identifiers), and
 *   <li>temporary credentials generated by the catalog service to access underlying storage.
 * </ul>
 *
 * <p>Authentication to the catalog service is performed using a bearer token supplied at
 * construction time. The token is attached to all outgoing REST requests.
 */
public class UnityCatalog implements DeltaCatalog {

  private static final Logger LOG = LoggerFactory.getLogger(UnityCatalog.class);

  private static ColumnTypeName columnTypeName(DataType dataType) {
    if (dataType instanceof IntegerType) {
      return ColumnTypeName.INT;
    } else if (dataType instanceof LongType) {
      return ColumnTypeName.LONG;
    } else if (dataType instanceof ShortType) {
      return ColumnTypeName.SHORT;
    } else if (dataType instanceof ByteType) {
      return ColumnTypeName.BYTE;
    } else if (dataType instanceof BooleanType) {
      return ColumnTypeName.BOOLEAN;
    } else if (dataType instanceof FloatType) {
      return ColumnTypeName.FLOAT;
    } else if (dataType instanceof DoubleType) {
      return ColumnTypeName.DOUBLE;
    } else if (dataType instanceof StringType) {
      return ColumnTypeName.STRING;
    } else if (dataType instanceof BinaryType) {
      return ColumnTypeName.BINARY;
    } else if (dataType instanceof DecimalType) {
      return ColumnTypeName.DECIMAL;
    } else if (dataType instanceof DateType) {
      return ColumnTypeName.DATE;
    } else if (dataType instanceof TimestampType) {
      return ColumnTypeName.TIMESTAMP;
    } else if (dataType instanceof TimestampNTZType) {
      return ColumnTypeName.TIMESTAMP_NTZ;
    } else if (dataType instanceof ArrayType) {
      return ColumnTypeName.ARRAY;
    } else if (dataType instanceof MapType) {
      return ColumnTypeName.MAP;
    } else if (dataType instanceof StructType) {
      return ColumnTypeName.STRUCT;
    } else {
      throw new UnsupportedOperationException("Unsupported data type: " + dataType);
    }
  }

  private static String typeText(DataType dataType) {
    if (dataType instanceof DecimalType) {
      DecimalType decimalType = (DecimalType) dataType;
      return String.format("DECIMAL(%d,%d)", decimalType.getPrecision(), decimalType.getScale());
    } else if (dataType instanceof BasePrimitiveType) {
      return dataType.toString().toUpperCase(Locale.ROOT);
    } else if (dataType instanceof ArrayType) {
      ArrayType arrayType = (ArrayType) dataType;
      return String.format("ARRAY<%s>", typeText(arrayType.getElementType()));
    } else if (dataType instanceof MapType) {
      MapType mapType = (MapType) dataType;
      return String.format(
          "MAP<%s,%s>", typeText(mapType.getKeyType()), typeText(mapType.getValueType()));
    } else if (dataType instanceof StructType) {
      StructType structType = (StructType) dataType;
      return String.format(
          "STRUCT<%s>",
          structType.fields().stream()
              .map(field -> String.format("%s:%s", field.getName(), typeText(field.getDataType())))
              .collect(Collectors.joining(",")));
    } else {
      throw new UnsupportedOperationException("Unsupported data type: " + dataType);
    }
  }

  enum AuthMode {
    token,
    oauth;
  }

  private final String name;
  private final URI endpoint;
  private final AuthMode authMode;
  private String token;
  private URI oauthUri;
  private String oauthClientId;
  private String oauthClientSecret;

  /**
   * Lazily initialized API client used to communicate with the catalog service. This field is
   * marked transient to avoid serialization issues in distributed environments.
   */
  protected transient ApiClient apiClient;

  /**
   * Creates a {@code RESTCatalog} with the given endpoint and authentication token.
   *
   * @param name catalog name
   * @param endpoint the catalog REST endpoint URI as a string
   * @param token a bearer token used to authenticate REST requests
   */
  public UnityCatalog(String name, URI endpoint, String token) {
    this.name = name;
    this.endpoint = endpoint;
    this.token = token;
    this.authMode = AuthMode.token;
  }

  /**
   * Creates a {@code RESTCatalog} with the given endpoint and OAuth authentication.
   *
   * @param name catalog name
   * @param endpoint the catalog REST endpoint URI as a string
   * @param oauthUri oauth uri
   * @param clientId oauth clientId
   * @param clientSecret oauth client secret
   */
  public UnityCatalog(
      String name, URI endpoint, URI oauthUri, String clientId, String clientSecret) {
    this.name = name;
    this.endpoint = endpoint;
    this.authMode = AuthMode.oauth;
    this.oauthUri = oauthUri;
    this.oauthClientId = clientId;
    this.oauthClientSecret = clientSecret;
  }

  /**
   * Returns the catalog name.
   *
   * @return the catalog name
   */
  public String getName() {
    return name;
  }

  /**
   * Returns the catalog REST endpoint.
   *
   * @return the catalog endpoint URI
   */
  public URI getEndpoint() {
    return endpoint;
  }

  /**
   * Returns the authentication token used for catalog access.
   *
   * @return the catalog bearer token
   */
  public String getToken() {
    return token;
  }

  @Override
  public void open() {
    if (apiClient == null) {
      Map<String, String> tokenProviderConf;
      switch (authMode) {
        case oauth:
          tokenProviderConf =
              Map.of(
                  "type",
                  "oauth",
                  "oauth.uri",
                  oauthUri.toString(),
                  "oauth.clientId",
                  oauthClientId,
                  "oauth.clientSecret",
                  oauthClientSecret);
          break;
        default:
          tokenProviderConf = Map.of("type", "static", "token", token);
      }
      apiClient =
          ApiClientBuilder.create()
              .uri(endpoint)
              .tokenProvider(TokenProvider.create(tokenProviderConf))
              .retryPolicy(JitterDelayRetryPolicy.builder().maxAttempts(5).build())
              .addAppVersion("DeltaFlink", "0.0.0")
              .build();
    }
  }

  protected <RET> RET withRetry(CheckedSupplier<RET> body) {
    // TODO implement retry
    try {
      return body.get();
    } catch (Throwable e) {
      if (e instanceof ApiException) {
        ApiException apiException = (ApiException) e;
        try {
          JsonNode node = new ObjectMapper().readTree(apiException.getResponseBody());
          switch (node.get("error_code").asText()) {
            case "TABLE_ALREADY_EXISTS":
              throw new ExceptionUtils.ResourceAlreadyExistException(node.get("message").asText());
            case "TABLE_DOES_NOT_EXIST":
              throw new ExceptionUtils.ResourceNotFoundException(node.get("message").asText());
            default:
              throw new RuntimeException(apiException);
          }
        } catch (JsonProcessingException ex) {
          throw new RuntimeException(ex);
        }
      }
      throw new RuntimeException(e);
    }
  }

  /**
   * Loads table metadata from the remote catalog.
   *
   * <p>This method retrieves table information via the catalog REST API and resolves the table
   * storage location into a normalized {@link URI}. The returned {@link TableDescriptor} contains
   * the table UUID and resolved storage path.
   *
   * @param tableName the logical identifier of the table
   * @return a {@link TableDescriptor} describing the resolved table
   */
  @Override
  public TableDescriptor getTable(String tableName) {
    Objects.requireNonNull(tableName);
    return withRetry(
        () -> {
          TablesApi tablesApi = new TablesApi(apiClient);
          TableInfo tableInfo = tablesApi.getTable(tableName, null, null);
          TableDescriptor brief = new TableDescriptor();
          brief.tablePath =
              AbstractKernelTable.normalize(
                  URI.create(Objects.requireNonNull(tableInfo.getStorageLocation())));
          brief.uuid = tableInfo.getTableId();
          LOG.debug("Loaded table with UUID {} at {}", brief.uuid, brief.tablePath);
          return brief;
        });
  }

  /**
   * Creates a new table in the backed UnityCatalog
   *
   * <p>The {@code tableId} identifies the table within UC. This operation registers the table
   * metadata with the remote catalog, including schema, partition specification, and table
   * properties.
   *
   * <p>This call will create a staging table, init the snapshot, then upgrade the staging table to
   * real table.
   */
  @Override
  public void createTable(
      String tableId,
      StructType schema,
      List<String> partitions,
      Map<String, String> properties,
      Consumer<TableDescriptor> callback) {
    Objects.requireNonNull(tableId);
    Objects.requireNonNull(schema);
    Objects.requireNonNull(partitions);
    Objects.requireNonNull(properties);
    withRetry(
        () -> {
          TablesApi tablesApi = new TablesApi(apiClient);
          // Obtain names
          String[] namespaces = tableId.split("\\.");
          Preconditions.checkArgument(namespaces.length == 2 || namespaces.length == 3);
          String schemaName;
          String tableName;
          if (namespaces.length == 3) {
            Preconditions.checkArgument(
                namespaces[0].equals(getName()),
                String.format(
                    "table's catalog name %s must match catalog's name %s",
                    namespaces[0], getName()));
            schemaName = namespaces[1];
            tableName = namespaces[2];
          } else {
            schemaName = namespaces[0];
            tableName = namespaces[1];
          }
          // Column Info
          List<ColumnInfo> columnInfos =
              IntStream.range(0, schema.fields().size())
                  .mapToObj(
                      index -> {
                        StructField field = schema.fields().get(index);
                        ColumnInfo colInfo =
                            new ColumnInfo()
                                .name(field.getName())
                                .typeName(columnTypeName(field.getDataType()))
                                .typeText(typeText(field.getDataType()))
                                .typeJson(DataTypeJsonSerDe.serializeDataType(field.getDataType()))
                                .position(index)
                                .nullable(field.isNullable());
                        if (field.getDataType() instanceof DecimalType) {
                          DecimalType decimalType = (DecimalType) field.getDataType();
                          colInfo
                              .typePrecision(decimalType.getPrecision())
                              .typeScale(decimalType.getScale());
                        }
                        return colInfo;
                      })
                  .collect(Collectors.toList());

          // Create a staging table and init the storage
          StagingTableInfo stagingTableInfo =
              tablesApi.createStagingTable(
                  new CreateStagingTable()
                      .catalogName(getName())
                      .schemaName(schemaName)
                      .name(tableName));

          // Init Delta snapshot
          String storageLocation = stagingTableInfo.getStagingLocation();
          Objects.requireNonNull(storageLocation);

          TableDescriptor desc =
              new TableDescriptor(tableId, stagingTableInfo.getId(), URI.create(storageLocation));
          callback.accept(desc);

          tablesApi.createTable(
              new CreateTable()
                  .catalogName(getName())
                  .schemaName(schemaName)
                  .name(tableName)
                  .storageLocation(stagingTableInfo.getStagingLocation())
                  .tableType(TableType.MANAGED)
                  .dataSourceFormat(DataSourceFormat.DELTA)
                  .columns(columnInfos)
                  .properties(properties));
          return null;
        });
  }

  /**
   * Retrieves temporary credentials required to access the underlying storage for the given table.
   *
   * <p>This implementation requests short-lived credentials from the catalog service that are
   * scoped to the specified table and operation type (read/write).
   *
   * <p>The returned configuration map contains Hadoop-compatible S3A credential keys.
   *
   * @param tableId the table identifier for which credentials are requested
   * @return a map of filesystem configuration properties containing temporary credentials
   * @throws RuntimeException if credential generation fails due to API or network errors
   */
  @Override
  public Map<String, String> getCredentials(String tableId) {
    return withRetry(
        () -> {
          TemporaryCredentialsApi credentialsApi = new TemporaryCredentialsApi(apiClient);
          TemporaryCredentials credentials =
              credentialsApi.generateTemporaryTableCredentials(
                  new GenerateTemporaryTableCredential()
                      .tableId(tableId)
                      .operation(TableOperation.READ_WRITE));

          Map<String, String> result = new HashMap<>();

          // AWS credentials
          // TODO: Add Azure and GCP credential support
          if (credentials.getAwsTempCredentials() != null) {
            result.put("fs.s3a.access.key", credentials.getAwsTempCredentials().getAccessKeyId());
            result.put(
                "fs.s3a.secret.key", credentials.getAwsTempCredentials().getSecretAccessKey());
            result.put(
                "fs.s3a.session.token", credentials.getAwsTempCredentials().getSessionToken());
            if (credentials.getExpirationTime() != null) {
              result.put(
                  CredentialManager.CREDENTIAL_EXPIRATION_KEY,
                  credentials.getExpirationTime().toString());
            }
          }
          return result;
        });
  }

  /* ===================================
   *     Extra UnityCatalog Operations
   * ==================================*/

  public List<String> listSchemas() {
    return withRetry(
        () -> {
          SchemasApi schemasApi = new SchemasApi(apiClient);
          return schemasApi.listSchemas(this.name, Integer.MAX_VALUE, null).getSchemas().stream()
              .map(SchemaInfo::getName)
              .collect(Collectors.toList());
        });
  }

  public SchemaInfo getSchema(String name) {
    return withRetry(
        () -> {
          SchemasApi schemasApi = new SchemasApi(apiClient);
          return schemasApi.getSchema(String.format("%s.%s", getName(), name));
        });
  }

  public List<String> listTables(String schema) {
    return withRetry(
        () -> {
          TablesApi tablesApi = new TablesApi(apiClient);
          return tablesApi.listTables(getName(), schema, Integer.MAX_VALUE, "").getTables().stream()
              .map(TableInfo::getName)
              .collect(Collectors.toList());
        });
  }

  public TableInfo getTableDetail(String tableId) {
    return withRetry(
        () -> {
          TablesApi tablesApi = new TablesApi(apiClient);
          return tablesApi.getTable(tableId, false, false);
        });
  }
}
